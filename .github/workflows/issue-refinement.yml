name: Issue Refinement Automation

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to refine'
        required: true
        type: number

permissions:
  issues: write
  contents: read
  pull-requests: read

jobs:
  refine-issue:
    runs-on: ubuntu-latest
    name: Automated Issue Refinement
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Analyze Issue and Assign Labels
      id: analyze
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueNumber = context.payload.issue ? context.payload.issue.number : ${{ github.event.inputs.issue_number || 'null' }};
          
          if (!issueNumber) {
            console.log('No issue number found');
            return;
          }
          
          // Get the issue details
          const { data: issue } = await github.rest.issues.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber
          });
          
          console.log(`Analyzing issue #${issueNumber}: ${issue.title}`);
          
          const title = issue.title.toLowerCase();
          const body = (issue.body || '').toLowerCase();
          const combinedText = `${title} ${body}`;
          
          // Story Points Assignment Logic based on realistic engineering effort
          // Focus: Time to complete, clarity of requirements, research needed, collaboration required
          let storyPoints = 3; // default to 3 for undefined cases
          let complexityReason = '';
          
          // 1 point: Super quick minor changes (typos, copy updates)
          const onePointKeywords = [
            'typo', 'copy', 'text update', 'wording', 'spelling', 
            'grammar', 'punctuation', 'link fix', 'broken link'
          ];
          
          // 2 points: Less than a day's work - clear requirements, no research
          const twoPointKeywords = [
            'small fix', 'quick fix', 'minor bug', 'css fix', 'styling issue',
            'minor update', 'small change', 'simple fix', 'config change', 'setting change'
          ];
          
          // 3 points: 1-2 days - mostly clear, minimal research/collaboration
          const threePointKeywords = [
            'bug fix', 'bug', 'enhancement', 'small feature', 'minor feature',
            'update documentation', 'improve', 'documentation update', 'docs update'
          ];
          
          // 5 points: 3-5 days - requires research and collaboration
          const fivePointKeywords = [
            'feature', 'new feature', 'implement', 'add feature', 'add new', 'create new',
            'integration', 'api endpoint', 'new component', 'ui component', 'frontend feature', 'backend feature'
          ];
          
          // 8 points: 6-10 days - significant research and collaboration
          const eightPointKeywords = [
            'complex feature', 'significant', 'major', 'redesign', 'overhaul',
            'multiple components', 'cross-team', 'integration with', 'third-party',
            'authentication', 'authorization', 'security', 'performance optimization'
          ];
          
          // 13 points: 11+ days - unclear requirements, discovery needed
          const thirteenPointKeywords = [
            'discovery', 'research', 'investigate', 'exploration', 'spike',
            'architecture', 'refactor', 'migration', 'new system', 'new service',
            'unclear', 'need to determine', 'figure out', 'not sure'
          ];
          
          // 21 points: 2+ sprints - project level, multiple tasks
          const twentyOnePointKeywords = [
            'project', 'initiative', 'multiple features', 'epic', 'program',
            'new product', 'major release', 'complete overhaul', 'full rewrite',
            'multiple teams', 'long-term', 'phased approach', 'rollout'
          ];
          
          let detectedKeywords = [];
          let matchedCategory = 'default';
          const bodyLength = (issue.body || '').length;
          
          // Check in priority order (highest to lowest) to avoid under-estimation
          // Check for 21 points first (project-level)
          for (const keyword of twentyOnePointKeywords) {
            if (combinedText.includes(keyword)) {
              storyPoints = 21;
              matchedCategory = '21-point';
              detectedKeywords.push(keyword);
              break;
            }
          }
          
          // Check for 13 points (discovery/unclear)
          if (matchedCategory === 'default') {
            for (const keyword of thirteenPointKeywords) {
              if (combinedText.includes(keyword)) {
                storyPoints = 13;
                matchedCategory = '13-point';
                detectedKeywords.push(keyword);
                break;
              }
            }
          }
          
          // Check for 8 points (complex with research)
          if (matchedCategory === 'default') {
            for (const keyword of eightPointKeywords) {
              if (combinedText.includes(keyword)) {
                storyPoints = 8;
                matchedCategory = '8-point';
                detectedKeywords.push(keyword);
                break;
              }
            }
          }
          
          // Check for 5 points (standard feature work)
          if (matchedCategory === 'default') {
            for (const keyword of fivePointKeywords) {
              if (combinedText.includes(keyword)) {
                storyPoints = 5;
                matchedCategory = '5-point';
                detectedKeywords.push(keyword);
                break;
              }
            }
          }
          
          // Check for 3 points (small work)
          if (matchedCategory === 'default') {
            for (const keyword of threePointKeywords) {
              if (combinedText.includes(keyword)) {
                storyPoints = 3;
                matchedCategory = '3-point';
                detectedKeywords.push(keyword);
                break;
              }
            }
          }
          
          // Check for 2 points (quick work)
          if (matchedCategory === 'default') {
            for (const keyword of twoPointKeywords) {
              if (combinedText.includes(keyword)) {
                storyPoints = 2;
                matchedCategory = '2-point';
                detectedKeywords.push(keyword);
                break;
              }
            }
          }
          
          // Check for 1 point (trivial changes)
          if (matchedCategory === 'default') {
            for (const keyword of onePointKeywords) {
              if (combinedText.includes(keyword)) {
                storyPoints = 1;
                matchedCategory = '1-point';
                detectedKeywords.push(keyword);
                break;
              }
            }
          }
          
          // Additional heuristics for better accuracy
          // Very short issues with minimal detail likely need clarification (but only if no keywords matched)
          if (bodyLength < 50 && matchedCategory === 'default') {
            storyPoints = 13;
            complexityReason = '11+ days: Insufficient detail provided, will require discovery and clarification';
          }
          // Long detailed issues suggest complexity
          else if (bodyLength > 2000 && storyPoints < 8) {
            storyPoints = Math.max(storyPoints, 8);
            complexityReason = '6-10 days: Extensive requirements suggest significant work with multiple considerations';
          }
          // Set complexity reasoning based on story points
          else if (storyPoints === 1) {
            complexityReason = 'Super quick: Minor change like fixing a typo or updating copy';
          } else if (storyPoints === 2) {
            complexityReason = 'Less than 1 day: Clear requirements, straightforward implementation';
          } else if (storyPoints === 3) {
            complexityReason = '1-2 days: Mostly clear with minimal research needed';
          } else if (storyPoints === 5) {
            complexityReason = '3-5 days: Requires research and collaboration to complete';
          } else if (storyPoints === 8) {
            complexityReason = '6-10 days: Significant work requiring substantial research and cross-team collaboration';
          } else if (storyPoints === 13) {
            complexityReason = '11+ days: Requirements unclear, will require discovery, extensive collaboration, and research';
          } else if (storyPoints === 21) {
            complexityReason = '2+ sprints: Project-level work requiring multiple tasks, research, collaboration, and approvals';
          }
          
          console.log(`Story points assigned: ${storyPoints}`);
          console.log(`Detected keywords: ${detectedKeywords.join(', ')}`);
          console.log(`Matched category: ${matchedCategory}`);
          
          // Priority Assignment Logic based on severity and urgency
          let priority = 'medium'; // default
          let priorityReason = '';
          
          // Critical priority indicators
          const criticalKeywords = [
            'critical', 'urgent', 'production down', 'security vulnerability', 
            'data loss', 'outage', 'blocking', 'p0', 'sev1'
          ];
          
          // High priority indicators  
          const highPriorityKeywords = [
            'high', 'important', 'asap', 'customer impact', 'revenue impact',
            'p1', 'sev2', 'deadline', 'release blocker'
          ];
          
          // Low priority indicators
          const lowPriorityKeywords = [
            'low', 'nice to have', 'future', 'enhancement', 'improvement',
            'p3', 'p4', 'sev3', 'sev4', 'backlog'
          ];
          
          if (criticalKeywords.some(keyword => combinedText.includes(keyword))) {
            priority = 'critical';
            priorityReason = 'Critical: Production impact, security issues, or blocking issues detected';
          } else if (highPriorityKeywords.some(keyword => combinedText.includes(keyword))) {
            priority = 'high';  
            priorityReason = 'High: Customer or revenue impact, or time-sensitive requirements';
          } else if (lowPriorityKeywords.some(keyword => combinedText.includes(keyword))) {
            priority = 'low';
            priorityReason = 'Low: Enhancement or non-urgent improvement';
          } else {
            priority = 'medium';
            priorityReason = 'Medium: Standard priority for new issues';
          }
          
          console.log(`Priority: ${priority} - ${priorityReason}`);
          
          // Get current labels to avoid duplicates
          const currentLabels = issue.labels.map(label => 
            typeof label === 'string' ? label : label.name
          );
          
          const newLabels = [...currentLabels];
          
          // Remove existing story point and priority labels
          const filteredLabels = newLabels.filter(label => 
            !label.startsWith('points-') && 
            !['priority-critical', 'priority-high', 'priority-medium', 'priority-low'].includes(label)
          );
          
          // Add new labels
          filteredLabels.push(`points-${storyPoints}`);
          filteredLabels.push(`priority-${priority}`);
          
          // Add refinement status
          if (!filteredLabels.includes('refined')) {
            filteredLabels.push('refined');
          }
          
          // Update issue with new labels
          await github.rest.issues.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            labels: filteredLabels
          });
          
          // Assign issue to "Intake" milestone
          const MILESTONE_NAME = 'Intake';
          try {
            // First, try to get the milestone (with pagination support)
            let intakeMilestone;
            let page = 1;
            let found = false;
            
            while (!found) {
              const milestones = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
                page: page
              });
              
              intakeMilestone = milestones.data.find(milestone => milestone.title === MILESTONE_NAME);
              
              if (intakeMilestone || milestones.data.length === 0) {
                found = true;
              } else {
                page++;
              }
            }
            
            // If milestone doesn't exist, create it
            if (!intakeMilestone) {
              const milestoneResponse = await github.rest.issues.createMilestone({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: MILESTONE_NAME,
                description: 'Issues that have been automatically refined and are ready for review by leads',
                state: 'open'
              });
              intakeMilestone = milestoneResponse.data;
              console.log(`Created "${MILESTONE_NAME}" milestone`);
            }
            
            // Assign the issue to the milestone
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              milestone: intakeMilestone.number
            });
            
            console.log(`Assigned issue #${issueNumber} to "${MILESTONE_NAME}" milestone`);
          } catch (error) {
            console.error('Error assigning milestone:', error.message);
            // Don't fail the workflow if milestone assignment fails
          }
          
          // Add analysis comment to the issue
          const analysisComment = "## 🤖 Automated Issue Refinement\n\n" +
            "**Story Points**: " + storyPoints + " points\n" +
            "**Priority**: " + priority.charAt(0).toUpperCase() + priority.slice(1) + "\n\n" +
            "### Analysis Details\n" +
            "- **Complexity Reasoning**: " + complexityReason + "\n" +
            "- **Priority Reasoning**: " + priorityReason + "\n" +
            "- **Keywords Detected**: " + (detectedKeywords.join(', ') || 'None') + "\n" +
            "- **Content Length**: " + bodyLength + " characters\n\n" +
            "### Next Steps\n" +
            "This issue has been automatically refined and added to the **Intake** milestone for review. The engineering team will validate the story point estimate and priority assignment during the next planning session.\n\n" +
            "---\n" +
            "*Generated automatically by [Issue Refinement Automation](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/actions/workflows/issue-refinement.yml)*";

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body: analysisComment
          });
          
          // Set outputs for notification step
          core.setOutput('issue-number', issueNumber);
          core.setOutput('story-points', storyPoints);
          core.setOutput('priority', priority);
          core.setOutput('title', issue.title);
          core.setOutput('complexity-reason', complexityReason);
          core.setOutput('priority-reason', priorityReason);
          
          return {
            issueNumber,
            storyPoints,
            priority,
            title: issue.title,
            complexityReason,
            priorityReason
          };
    
    - name: Create Labels if they don't exist
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const labels = [
            // Story point labels
            { name: 'points-1', color: 'e6f3ff', description: '1 story point - Super quick minor change' },
            { name: 'points-2', color: 'd9ebff', description: '2 story points - Less than a day of work' },
            { name: 'points-3', color: 'd1e7ff', description: '3 story points - 1-2 days of work' },
            { name: 'points-5', color: 'a8d4ff', description: '5 story points - 3-5 days of work' },
            { name: 'points-8', color: '7fc3ff', description: '8 story points - 6-10 days of work' },
            { name: 'points-13', color: '4ea5ff', description: '13 story points - 11+ days of work, discovery needed' },
            { name: 'points-21', color: '2d7fd8', description: '21 story points - 2+ sprints, project-level work' },
            
            // Priority labels
            { name: 'priority-critical', color: 'ff0000', description: 'Critical priority - immediate attention required' },
            { name: 'priority-high', color: 'ff6600', description: 'High priority - important and time-sensitive' },
            { name: 'priority-medium', color: 'ffcc00', description: 'Medium priority - standard priority' },
            { name: 'priority-low', color: '99ff99', description: 'Low priority - nice to have' },
            
            // Process labels
            { name: 'refined', color: '0e8a16', description: 'Issue has been automatically refined' }
          ];
          
          for (const label of labels) {
            try {
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: label.name,
                color: label.color,
                description: label.description
              });
              console.log(`Created label: ${label.name}`);
            } catch (error) {
              if (error.status === 422) {
                console.log(`Label ${label.name} already exists`);
              } else {
                console.error(`Error creating label ${label.name}:`, error.message);
              }
            }
          }
          
    - name: Send Notification
      uses: actions/github-script@v7  
      if: steps.analyze.outputs.issue-number
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueNumber = '${{ steps.analyze.outputs.issue-number }}';
          const storyPoints = '${{ steps.analyze.outputs.story-points }}';
          const priority = '${{ steps.analyze.outputs.priority }}';
          const title = '${{ steps.analyze.outputs.title }}';
          const complexityReason = '${{ steps.analyze.outputs.complexity-reason }}';
          const priorityReason = '${{ steps.analyze.outputs.priority-reason }}';
          
          console.log(`📋 Issue #${issueNumber} refined and ready for review:`);
          console.log(`📌 Title: ${title}`);
          console.log(`⚡ Story Points: ${storyPoints}`);
          console.log(`🚀 Priority: ${priority}`);
          console.log(`🔍 Complexity: ${complexityReason}`);
          console.log(`📈 Priority Logic: ${priorityReason}`);
          
          // Try to find a refinement tracking issue or create notifications
          try {
            // Look for existing refinement tracking issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'refinement-tracking',
              state: 'open'
            });
            
            let trackingIssue = issues.data[0];
            
            if (!trackingIssue) {
              // Create refinement tracking issue
              const trackingIssueResponse = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '📋 Issue Refinement Tracking',
                body: "This issue tracks all automatically refined issues that are ready for review.\n\n## Recently Refined Issues\n\nIssue refinements will be posted as comments below.",
                labels: ['refinement-tracking', 'automation']
              });
              trackingIssue = trackingIssueResponse.data;
              console.log(`Created refinement tracking issue #${trackingIssue.number}`);
            }
            
            // Post notification to tracking issue
            const notificationComment = "## 📋 New Issue Refined - Ready for Review\n\n" +
              "**Issue**: #" + issueNumber + " - " + title + "\n" +
              "**Story Points**: " + storyPoints + " points\n" +
              "**Priority**: " + priority.charAt(0).toUpperCase() + priority.slice(1) + "\n" +
              "**Refined**: " + new Date().toISOString().split('T')[0] + "\n\n" +
              "**Analysis Summary**:\n" +
              "- " + complexityReason + "\n" +
              "- " + priorityReason + "\n\n" +
              "[View Issue #" + issueNumber + "](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/issues/" + issueNumber + ")\n\n" +
              "---";

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: trackingIssue.number,
              body: notificationComment
            });
            
            console.log(`✅ Notification posted to tracking issue #${trackingIssue.number}`);
            
          } catch (error) {
            console.error('Error creating notification:', error.message);
          }